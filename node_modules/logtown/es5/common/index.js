'use strict';

var get = require('dlv');
var set = require('dset');
var deepmerge = require('deepmerge');
var isPlainObject = require('is-plain-object');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var deepMergeOptions = {
  isMergeableObject: function isMergeableObject(obj) {
    return isPlainObject(obj) || Array.isArray(obj);
  }
};
var loggers = {};
var configRegistry = {};
var wrappers = [];
var pluginsRegistry = [];
var LEVELS = Object.freeze({
  SILLY: 'SILLY',
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR'
});
var WRAPPER_OPTS_SYMBOL = Symbol();
var WRAPPER_OPTS_KEY = 'logOptions';
var WRAPPER_PLUGINS_KEY = 'logPlugins';

function buildMessageOptions(id) {
  var _configRegistry = configRegistry,
      namespaces = _configRegistry.namespaces,
      disable = _configRegistry.disable,
      confs = _objectWithoutProperties(_configRegistry, ["namespaces", "disable"]);

  var options = deepmerge.all([{}, get(configRegistry, "namespaces.".concat(id), {}), {
    disable: get(configRegistry, 'disable', [])
  }, confs, {
    disable: configRegistry.useGlobal ? get(global, "logtown.namespaces.".concat(id, ".disable"), []) : []
  }], deepMergeOptions);
  options.disable = options.disable.map(function (d) {
    return d.toUpperCase();
  });
  return options;
}

function equalsWrapperOptValue(wrapper, opt, value) {
  return get(wrapper, ['constructor', WRAPPER_OPTS_KEY, opt]) === value || get(wrapper, [WRAPPER_OPTS_SYMBOL, opt]) === value;
}

function extractWrapperPlugins(wrapper) {
  return get(wrapper, ['constructor', WRAPPER_PLUGINS_KEY]) || get(wrapper, [WRAPPER_OPTS_SYMBOL, 'plugins']);
}
/**
 * Send log message to all available wrappers
 *
 * @param {string} id
 * @param {string} level
 * @param {boolean} fallbackToLog
 * @param {[]} rest
 */


function sendMessage(id, level, fallbackToLog) {
  for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    rest[_key - 3] = arguments[_key];
  }

  var levelMethod = level.toLowerCase();
  var options = buildMessageOptions(id);
  var tagsToDisable = get(configRegistry, 'tags.disable', []);
  var namespaceTags = get(configRegistry, "namespaces.".concat(id, ".tags"), []);
  var containsDisabledTag = tagsToDisable.some(function (element) {
    return namespaceTags.indexOf(element) > -1;
  });

  if (options.disable.indexOf(level) > -1 || containsDisabledTag) {
    // if global or logger's setting is saying to disable logging, proceed silently
    if (!!configRegistry.verbose) {
      console.log("Level ".concat(level, " or namespace ID ").concat(id, " has been disabled. skipping..."));
    }

    return;
  }

  var _applyPlugins = applyPlugins.apply(void 0, [pluginsRegistry, id, level, calcStats()].concat(rest)),
      _applyPlugins2 = _toArray(_applyPlugins),
      stats = _applyPlugins2[2],
      args = _applyPlugins2.slice(3);

  wrappers.concat(options.wrappers).forEach(function (wrapper) {
    var restOrArgs = equalsWrapperOptValue(wrapper, 'passInitialArguments', true) ? rest : args;
    var plugins = extractWrapperPlugins(wrapper);

    var _applyPlugins3 = applyPlugins.apply(void 0, [plugins, id, level, stats].concat(_toConsumableArray(restOrArgs))),
        _applyPlugins4 = _toArray(_applyPlugins3),
        wrapperStats = _applyPlugins4[2],
        wrapperArgs = _applyPlugins4.slice(3);

    if (typeof wrapper[levelMethod] === 'function') {
      // use specific logging method if exists, for example, wrapper.info()
      return wrapper[levelMethod].apply(wrapper, [id, wrapperStats].concat(_toConsumableArray(wrapperArgs)));
    } else if (typeof wrapper.log === 'function' && !!fallbackToLog) {
      // use generic log method, if fallbackToLog === true. It is always equal to TRUE for standard levels
      return wrapper.log.apply(wrapper, [id, level, wrapperStats].concat(_toConsumableArray(wrapperArgs)));
    }

    if (!!configRegistry.verbose) {
      console.log("Wrapper has no valid logging method. fallbackToLog is equal ".concat(fallbackToLog, ". skipping..."));
    }
  });
}
/**
 * Prepare stats. Currently only maxIdLength supported in core, can be extended
 * in custom plugin.
 *
 * @return {{maxIdLength: number}}
 */


function calcStats() {
  return {
    maxIdLength: Math.max.apply(Math, _toConsumableArray(Object.keys(loggers).map(function (l) {
      return l.length;
    })))
  };
}
/**
 * Run all plugins. Must return always non empty array with [id, level, stats, ...rest]
 *
 * @param {[]} plugins
 * @param {string} id
 * @param {string} level
 * @param {{}} stats
 * @param {*} rest
 * @return {[]}
 */


function applyPlugins() {
  var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var id = arguments.length > 1 ? arguments[1] : undefined;
  var level = arguments.length > 2 ? arguments[2] : undefined;
  var stats = arguments.length > 3 ? arguments[3] : undefined;

  for (var _len2 = arguments.length, rest = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
    rest[_key2 - 4] = arguments[_key2];
  }

  if (!Array.isArray(plugins) || !plugins.every(function (p) {
    return typeof p === 'function';
  })) {
    throw new Error('Plugins MUST be an array of functions');
  }

  var args = Object.freeze(rest.map(function (arg) {
    return Object.freeze(arg);
  })); // mutable context object that passes into plugin function and
  // should be modified with new args or stats
  // id, level and initial arguments array MUST not be modified

  var ctx = {
    get id() {
      return id;
    },

    get level() {
      return level;
    },

    get arguments() {
      return args;
    },

    stats: stats,
    args: rest
  };
  plugins.forEach(function (pluginFn) {
    pluginFn(ctx);
  });
  var resArgs = Array.isArray(ctx.args) && ctx.args.length ? ctx.args : ctx.arguments;
  return [id, level, ctx.stats].concat(_toConsumableArray(resArgs));
}
/**
 * Create new logger instance
 *
 * @param {string} id
 * @return {{id, silly: (function(...[*])), debug: (function(...[*])), info: (function(...[*])), warn: (function(...[*])), error: (function(...[*]))}}
 */


function createLogger(id) {
  var log = function log(level, fallbackToLog) {
    for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      rest[_key3 - 2] = arguments[_key3];
    }

    return sendMessage.apply(void 0, [id, level, fallbackToLog].concat(rest));
  };

  return {
    get id() {
      return id;
    },

    silly: function silly() {
      for (var _len4 = arguments.length, rest = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        rest[_key4] = arguments[_key4];
      }

      log.apply(void 0, [LEVELS.SILLY, true].concat(rest));
    },
    debug: function debug() {
      for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        rest[_key5] = arguments[_key5];
      }

      log.apply(void 0, [LEVELS.DEBUG, true].concat(rest));
    },
    info: function info() {
      for (var _len6 = arguments.length, rest = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        rest[_key6] = arguments[_key6];
      }

      log.apply(void 0, [LEVELS.INFO, true].concat(rest));
    },
    warn: function warn() {
      for (var _len7 = arguments.length, rest = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        rest[_key7] = arguments[_key7];
      }

      log.apply(void 0, [LEVELS.WARN, true].concat(rest));
    },
    error: function error() {
      for (var _len8 = arguments.length, rest = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        rest[_key8] = arguments[_key8];
      }

      log.apply(void 0, [LEVELS.ERROR, true].concat(rest));
    },
    // CAUTION: experimental feature
    send: function send(level) {
      for (var _len9 = arguments.length, rest = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
        rest[_key9 - 1] = arguments[_key9];
      }

      log.apply(void 0, [level, false].concat(rest));
    }
  };
}
/**
 * Returns array if not array is passed to the function
 *
 * @param {[]|any} value
 * @return {[]}
 */


function normalizeArray() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (Array.isArray(value)) {
    return value;
  }

  return [value];
}
/**
 * Get logger that exits or create new one
 *
 * @param {String} id
 * @param {[]} disable
 * @param {[]} wrappers
 * @param {[]} tags
 * @returns {{silly: Function, debug: Function, info: Function, warn: Function, error: Function}}
 */


function getLogger(id) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$disable = _ref.disable,
      disable = _ref$disable === void 0 ? [] : _ref$disable,
      _ref$wrappers = _ref.wrappers,
      wrappers = _ref$wrappers === void 0 ? [] : _ref$wrappers,
      _ref$tags = _ref.tags,
      tags = _ref$tags === void 0 ? [] : _ref$tags;

  var config = {
    disable: normalizeArray(disable).map(function (v) {
      return v + '';
    }),
    wrappers: normalizeArray(wrappers),
    tags: normalizeArray(tags)
  };
  set(configRegistry, "namespaces.".concat(id), deepmerge(get(configRegistry, "namespaces.".concat(id), {}), config, deepMergeOptions));
  return loggers[id] || (loggers[id] = createLogger(id));
}
/**
 * Add global configs
 *
 * @param {boolean} useGlobal
 * @param {[]} disable
 * @param {{}} namespaces
 * @param {{}} tags
 * @param {boolean} verbose
 * @param {boolean} override
 */


function configure() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$useGlobal = _ref2.useGlobal,
      useGlobal = _ref2$useGlobal === void 0 ? true : _ref2$useGlobal,
      _ref2$disable = _ref2.disable,
      disable = _ref2$disable === void 0 ? [] : _ref2$disable,
      _ref2$namespaces = _ref2.namespaces,
      namespaces = _ref2$namespaces === void 0 ? {} : _ref2$namespaces,
      _ref2$tags = _ref2.tags,
      tags = _ref2$tags === void 0 ? {} : _ref2$tags,
      _ref2$verbose = _ref2.verbose,
      verbose = _ref2$verbose === void 0 ? false : _ref2$verbose;

  var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var config = Object.create(null);
  config.useGlobal = !!useGlobal;
  config.disable = normalizeArray(disable).map(function (v) {
    return v + '';
  });
  config.namespaces = namespaces;
  config.tags = {
    disable: normalizeArray(get(tags, 'disable', []))
  };
  config.verbose = verbose;
  configRegistry = override ? config : deepmerge(configRegistry, config, deepMergeOptions);
}
/**
 * Add new wrapper. Can handle any object with one of methods from array:
 * ['log', 'silly', 'debug', 'info', 'warn', 'error']
 *
 * @param {{log?: Function, silly?: Function, debug?: Function, info?: Function, warn?: Function, error?: Function}|Function} wrapper
 * @param {{}} opts
 */


function addWrapper(wrapper) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$passInitialArgu = _ref3.passInitialArguments,
      passInitialArguments = _ref3$passInitialArgu === void 0 ? false : _ref3$passInitialArgu,
      _ref3$plugins = _ref3.plugins,
      plugins = _ref3$plugins === void 0 ? [] : _ref3$plugins;

  var opts = {
    passInitialArguments: passInitialArguments,
    plugins: normalizeArray(plugins)
  };

  if (_typeof(wrapper) === 'object' && !Array.isArray(wrapper) && (typeof wrapper.log === 'function' || Object.keys(LEVELS).some(function (lvl) {
    return typeof wrapper[lvl.toLowerCase()] === 'function';
  }))) {
    // if wrapper is instance of some class or pure object, it must include at least one method with level name
    wrapper[WRAPPER_OPTS_SYMBOL] = opts;
    wrappers.push(wrapper);
    return;
  }

  if (typeof wrapper === 'function') {
    var wrapperObject = _defineProperty({
      log: wrapper
    }, WRAPPER_OPTS_SYMBOL, opts);

    wrappers.push(wrapperObject);
    return;
  }

  throw new Error('Wrapper did not implemented a minimum methods required');
}
/**
 * Add plugin function. Plugin function must return array with log argument values.
 */


function addPlugin(useLevel, fn) {
  var pluginFn = fn;

  if (typeof fn === 'undefined' && typeof useLevel === 'function') {
    pluginFn = useLevel;
  }

  if (typeof pluginFn !== 'function') {
    throw new Error('Plugin must be a function!');
  }

  if (typeof useLevel === 'string') {
    pluginFn = function pluginFn(id, level, stats) {
      for (var _len10 = arguments.length, rest = new Array(_len10 > 3 ? _len10 - 3 : 0), _key10 = 3; _key10 < _len10; _key10++) {
        rest[_key10 - 3] = arguments[_key10];
      }

      if (level === useLevel.toUpperCase()) {
        return fn.apply(void 0, [id, level, stats].concat(rest));
      }

      return [id, level, stats].concat(rest);
    };
  }

  pluginsRegistry.push(pluginFn);
}

function cleanPlugins() {
  pluginsRegistry.splice(0, pluginsRegistry.length);
}

function cleanWrappers() {
  wrappers.splice(0, wrappers.length);
}
/**
 * Clean wrappers, plugins and configurations
 */


function cleanAll() {
  cleanWrappers();
  cleanPlugins();
  configure({}, true);
}
/**
 * Factory method which returns logger. alias to getLogger()
 *
 * @param {string} id
 * @param {[]} disable
 * @param {[]} wrappers
 * @returns {{silly: Function, debug: Function, info: Function, warn: Function, error: Function}}
 */


var factory = function factory() {
  return getLogger.apply(void 0, arguments);
};

factory.getLogger = getLogger;
factory.configure = configure;
factory.addWrapper = addWrapper;
factory.addPlugin = addPlugin;
factory.LEVELS = LEVELS;
factory.cleanAll = cleanAll;
factory.cleanWrappers = cleanWrappers;
factory.cleanPlugins = cleanPlugins;

module.exports = factory;
